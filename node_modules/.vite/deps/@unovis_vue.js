import {
  Annotations,
  Area,
  Axis,
  Brush,
  BulletLegend,
  ChordDiagram,
  Crosshair,
  Donut,
  FreeBrush,
  Graph,
  GroupedBar,
  LeafletFlowMap,
  LeafletMap,
  Line,
  NestedDonut,
  Sankey,
  Scatter,
  SingleContainer,
  StackedBar,
  Timeline,
  Tooltip,
  TopoJSONMap,
  XYContainer,
  XYLabels
} from "./chunk-Z7HDWFM6.js";
import "./chunk-AXVSVYA2.js";
import {
  isEqual
} from "./chunk-NGMURNR6.js";
import {
  camelize,
  computed,
  createElementBlock,
  defineComponent,
  getCurrentInstance,
  inject,
  nextTick,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderSlot,
  toRaw,
  toRefs,
  watch,
  watchEffect
} from "./chunk-U3LI7FBV.js";
import "./chunk-PR4QN5HX.js";

// node_modules/@unovis/vue/utils/context.js
var o = Symbol("componentAccessorKey");
var s = Symbol("tooltipAccessorKey");
var c = Symbol("crosshairAccessorKey");
var e = Symbol("axisAccessorKey");
var t = Symbol("annotationsAccessorKey");

// node_modules/@unovis/vue/utils/props.js
function f(t2, r) {
  return isEqual(t2, r);
}
function m(t2) {
  const r = getCurrentInstance(), n = r.attrs;
  return computed(() => {
    const o2 = {}, c2 = (r == null ? void 0 : r.vnode.props) ?? {};
    return Object.keys(c2).forEach((e2) => {
      o2[camelize(e2)] = t2[camelize(e2)];
    }), { ...o2, ...n };
  });
}

// node_modules/@unovis/vue/containers/xy-container/index.js
var $ = defineComponent({
  __name: "index",
  props: {
    components: {},
    xScale: { type: [Object, Function] },
    xDomain: {},
    xDomainMinConstraint: {},
    xDomainMaxConstraint: {},
    xRange: {},
    yScale: { type: [Object, Function] },
    yDomain: {},
    yDomainMinConstraint: {},
    yDomainMaxConstraint: {},
    yRange: {},
    yDirection: {},
    xAxis: {},
    yAxis: {},
    autoMargin: { type: Boolean },
    tooltip: {},
    crosshair: {},
    preventEmptyDomain: { type: [Boolean, null] },
    scaleByDomain: { type: Boolean },
    annotations: {},
    duration: {},
    margin: {},
    padding: {},
    sizing: {},
    width: {},
    height: {},
    svgDefs: {},
    ariaLabel: {},
    data: {}
  },
  setup(d, { expose: l }) {
    const c2 = d, { data: t2 } = toRefs(c2), m2 = m(c2), n = ref(), e2 = reactive({
      components: [],
      annotations: void 0,
      crosshair: void 0,
      tooltip: void 0,
      xAxis: void 0,
      yAxis: void 0
    }), s2 = ref();
    return watch(t2, () => {
      n.value && n.value.setData(t2.value, true);
    }), watchEffect(() => {
      var o2;
      e2.components.map((i) => i.config), (o2 = n.value) == null || o2.updateContainer({ ...toRaw(m2.value), ...toRaw(e2) });
    }), onMounted(() => {
      s2.value && (n.value = new XYContainer(s2.value, { ...toRaw(e2) }, t2.value));
    }), onUnmounted(() => {
      var o2;
      return (o2 = n.value) == null ? void 0 : o2.destroy();
    }), provide(o, {
      data: t2,
      update: (o2) => e2.components = [...e2.components, o2],
      destroy: () => {
        var o2;
        return e2.components = (o2 = e2.components) == null ? void 0 : o2.filter((i) => !i.isDestroyed());
      }
    }), provide(e, {
      data: t2,
      update: (o2) => e2[`${o2.config.type}Axis`] = o2,
      destroy: (o2) => {
        e2[`${o2}Axis`] = void 0;
      }
    }), provide(c, {
      data: t2,
      update: (o2) => e2.crosshair = o2,
      destroy: () => {
        e2.crosshair = void 0;
      }
    }), provide(s, {
      data: t2,
      update: (o2) => e2.tooltip = o2,
      destroy: () => {
        e2.tooltip = void 0;
      }
    }), provide(t, {
      data: t2,
      update: (o2) => e2.annotations = o2,
      destroy: () => {
        e2.annotations = void 0;
      }
    }), l({
      component: n
    }), (o2, i) => (openBlock(), createElementBlock("div", {
      "data-vis-xy-container": "",
      ref_key: "elRef",
      ref: s2,
      class: "unovis-xy-container"
    }, [
      renderSlot(o2.$slots, "default")
    ], 512));
  }
});

// node_modules/@unovis/vue/containers/single-container/index.js
var b = defineComponent({
  __name: "index",
  props: {
    component: {},
    tooltip: {},
    annotations: {},
    duration: {},
    margin: {},
    padding: {},
    sizing: {},
    width: {},
    height: {},
    svgDefs: {},
    ariaLabel: {},
    data: {}
  },
  setup(c2, { expose: d }) {
    const r = c2, { data: n } = toRefs(r), l = m(r);
    let o2;
    const e2 = reactive({
      component: void 0,
      tooltip: void 0,
      annotations: void 0
    }), i = ref(), p = () => {
      o2 || i.value && e2.component && (o2 = new SingleContainer(i.value, { ...toRaw(e2) }, n.value));
    };
    return watchEffect(() => {
      var t2;
      p(), (t2 = e2.component) == null || t2.config, o2 == null || o2.updateContainer({ ...toRaw(l.value), ...toRaw(e2) });
    }), watch(n, () => {
      o2 ? o2.setData(n.value, true) : p();
    }), onUnmounted(() => o2 == null ? void 0 : o2.destroy()), provide(o, {
      data: n,
      update: (t2) => e2.component = t2,
      destroy: () => e2.component = void 0
    }), provide(s, {
      data: n,
      update: (t2) => e2.tooltip = t2,
      destroy: () => {
        e2.tooltip = void 0;
      }
    }), provide(t, {
      data: n,
      update: (t2) => e2.annotations = t2,
      destroy: () => {
        e2.annotations = void 0;
      }
    }), d({
      component: o2
    }), (t2, B4) => (openBlock(), createElementBlock("div", {
      "data-vis-single-container": "",
      ref_key: "elRef",
      ref: i,
      class: "unovis-single-container"
    }, [
      renderSlot(t2.$slots, "default")
    ], 512));
  }
});

// node_modules/@unovis/vue/components/area/index.js
var j = { "data-vis-component": "" };
var D = Area.selectors;
var P = defineComponent({
  __name: "index",
  props: {
    color: {},
    curveType: {},
    baseline: {},
    opacity: {},
    cursor: {},
    minHeight1Px: { type: Boolean },
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l, { expose: p }) {
    const o2 = inject(o), c2 = l, a = computed(() => o2.data.value ?? c2.data), n = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Area(n.value), (e2 = t2.value) == null || e2.setData(a.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(n, (e2, r) => {
      var s2;
      f(e2, r) || (s2 = t2.value) == null || s2.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(a.value);
    }), p({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", j));
  }
});

// node_modules/@unovis/vue/components/axis/index.js
var b2 = { "data-vis-axis": "" };
var M = Axis.selectors;
var O = defineComponent({
  __name: "index",
  props: {
    position: {},
    type: {},
    fullSize: { type: Boolean },
    label: {},
    labelFontSize: {},
    labelMargin: {},
    labelColor: {},
    gridLine: { type: Boolean },
    tickLine: { type: Boolean },
    domainLine: { type: Boolean },
    minMaxTicksOnly: { type: Boolean },
    minMaxTicksOnlyWhenWidthIsLess: {},
    tickFormat: { type: Function },
    tickValues: {},
    numTicks: {},
    tickTextFitMode: {},
    tickTextWidth: {},
    tickTextSeparator: {},
    tickTextForceWordBreak: { type: Boolean },
    tickTextTrimType: {},
    tickTextFontSize: {},
    tickTextAlign: {},
    tickTextColor: {},
    tickTextAngle: {},
    tickTextHideOverlapping: { type: Boolean },
    tickPadding: {},
    x: {},
    y: {},
    id: { type: Function },
    color: {},
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: u }) {
    const o2 = inject(e), a = p, n = computed(() => o2.data.value ?? a.data), i = m(a), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Axis(i.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy(a.type);
    }), watch(i, (e2, c2) => {
      var l;
      f(e2, c2) || (l = t2.value) == null || l.setConfig(i.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), u({
      component: t2
    }), (e2, c2) => (openBlock(), createElementBlock("div", b2));
  }
});

// node_modules/@unovis/vue/components/brush/index.js
var S = { "data-vis-component": "" };
var D2 = Brush.selectors;
var E = defineComponent({
  __name: "index",
  props: {
    onBrush: { type: Function },
    onBrushStart: { type: Function },
    onBrushMove: { type: Function },
    onBrushEnd: { type: Function },
    handleWidth: {},
    selection: {},
    draggable: { type: Boolean },
    handlePosition: {},
    selectionMinLength: {},
    x: {},
    y: {},
    id: { type: Function },
    color: {},
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l, { expose: p }) {
    const o2 = inject(o), c2 = l, n = computed(() => o2.data.value ?? c2.data), a = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Brush(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, s2) => {
      var r;
      f(e2, s2) || (r = t2.value) == null || r.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), p({
      component: t2
    }), (e2, s2) => (openBlock(), createElementBlock("div", S));
  }
});

// node_modules/@unovis/vue/components/crosshair/index.js
var B = { "data-vis-crosshair": "" };
var q = Crosshair.selectors;
var A = defineComponent({
  __name: "index",
  props: {
    data: {}
  },
  setup(l, { expose: p }) {
    const t2 = inject(c), r = l, a = computed(() => t2.data.value ?? r.data), s2 = m(r), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new Crosshair(s2.value), (e2 = o2.value) == null || e2.setData(a.value), t2.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), t2.destroy();
    }), watch(s2, (e2, n) => {
      var c2;
      f(e2, n) || (c2 = o2.value) == null || c2.setConfig(s2.value);
    }), watch(a, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(a.value);
    }), p({
      component: o2
    }), (e2, n) => (openBlock(), createElementBlock("div", B));
  }
});

// node_modules/@unovis/vue/components/free-brush/index.js
var g = { "data-vis-component": "" };
var D3 = FreeBrush.selectors;
var E2 = defineComponent({
  __name: "index",
  props: {
    mode: {},
    onBrush: { type: Function },
    onBrushStart: { type: Function },
    onBrushMove: { type: Function },
    onBrushEnd: { type: Function },
    handleWidth: {},
    selection: {},
    selectionMinLength: {},
    autoHide: { type: Boolean },
    x: {},
    y: {},
    id: { type: Function },
    color: {},
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l, { expose: p }) {
    const o2 = inject(o), c2 = l, n = computed(() => o2.data.value ?? c2.data), a = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new FreeBrush(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, s2) => {
      var r;
      f(e2, s2) || (r = t2.value) == null || r.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), p({
      component: t2
    }), (e2, s2) => (openBlock(), createElementBlock("div", g));
  }
});

// node_modules/@unovis/vue/components/grouped-bar/index.js
var C = { "data-vis-component": "" };
var w = GroupedBar.selectors;
var D4 = defineComponent({
  __name: "index",
  props: {
    color: {},
    groupWidth: {},
    groupMaxWidth: {},
    dataStep: {},
    groupPadding: {},
    barPadding: {},
    roundedCorners: { type: [Number, Boolean] },
    barMinHeight: {},
    cursor: {},
    orientation: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(d, { expose: p }) {
    const t2 = inject(o), r = d, a = computed(() => t2.data.value ?? r.data), n = m(r), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new GroupedBar(n.value), (e2 = o2.value) == null || e2.setData(a.value), t2.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), t2.destroy();
    }), watch(n, (e2, c2) => {
      var s2;
      f(e2, c2) || (s2 = o2.value) == null || s2.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(a.value);
    }), p({
      component: o2
    }), (e2, c2) => (openBlock(), createElementBlock("div", C));
  }
});

// node_modules/@unovis/vue/components/line/index.js
var b3 = { "data-vis-component": "" };
var O2 = Line.selectors;
var S2 = defineComponent({
  __name: "index",
  props: {
    color: {},
    curveType: {},
    lineWidth: {},
    lineDashArray: {},
    fallbackValue: {},
    highlightOnHover: { type: Boolean },
    cursor: {},
    interpolateMissingData: { type: Boolean },
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u, { expose: p }) {
    const o2 = inject(o), c2 = u, a = computed(() => o2.data.value ?? c2.data), n = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Line(n.value), (e2 = t2.value) == null || e2.setData(a.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(n, (e2, r) => {
      var s2;
      f(e2, r) || (s2 = t2.value) == null || s2.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(a.value);
    }), p({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", b3));
  }
});

// node_modules/@unovis/vue/components/scatter/index.js
var k = { "data-vis-component": "" };
var w2 = Scatter.selectors;
var z = defineComponent({
  __name: "index",
  props: {
    color: {},
    size: {},
    sizeScale: { type: [Object, Function] },
    sizeRange: {},
    shape: { type: [Function, String] },
    label: {},
    labelColor: {},
    labelHideOverlapping: { type: Boolean },
    cursor: {},
    labelTextBrightnessRatio: {},
    labelPosition: {},
    strokeColor: {},
    strokeWidth: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u, { expose: p }) {
    const o2 = inject(o), c2 = u, a = computed(() => o2.data.value ?? c2.data), n = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Scatter(n.value), (e2 = t2.value) == null || e2.setData(a.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(n, (e2, s2) => {
      var r;
      f(e2, s2) || (r = t2.value) == null || r.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(a.value);
    }), p({
      component: t2
    }), (e2, s2) => (openBlock(), createElementBlock("div", k));
  }
});

// node_modules/@unovis/vue/components/stacked-bar/index.js
var k2 = { "data-vis-component": "" };
var j2 = StackedBar.selectors;
var w3 = defineComponent({
  __name: "index",
  props: {
    color: {},
    barWidth: {},
    barMaxWidth: {},
    dataStep: {},
    barPadding: {},
    roundedCorners: { type: [Number, Boolean] },
    cursor: {},
    barMinHeight1Px: { type: Boolean },
    barMinHeightZeroValue: {},
    orientation: {},
    x: {},
    y: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(d, { expose: l }) {
    const o2 = inject(o), r = d, a = computed(() => o2.data.value ?? r.data), n = m(r), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new StackedBar(n.value), (e2 = t2.value) == null || e2.setData(a.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(n, (e2, c2) => {
      var s2;
      f(e2, c2) || (s2 = t2.value) == null || s2.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(a.value);
    }), l({
      component: t2
    }), (e2, c2) => (openBlock(), createElementBlock("div", k2));
  }
});

// node_modules/@unovis/vue/components/timeline/index.js
var B2 = { "data-vis-component": "" };
var j3 = Timeline.selectors;
var q2 = defineComponent({
  __name: "index",
  props: {
    data: {}
  },
  setup(l, { expose: p }) {
    const t2 = inject(o), s2 = l, a = computed(() => t2.data.value ?? s2.data), n = m(s2), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new Timeline(n.value), (e2 = o2.value) == null || e2.setData(a.value), t2.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), t2.destroy();
    }), watch(n, (e2, c2) => {
      var r;
      f(e2, c2) || (r = o2.value) == null || r.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(a.value);
    }), p({
      component: o2
    }), (e2, c2) => (openBlock(), createElementBlock("div", B2));
  }
});

// node_modules/@unovis/vue/components/xy-labels/index.js
var k3 = { "data-vis-component": "" };
var j4 = XYLabels.selectors;
var w4 = defineComponent({
  __name: "index",
  props: {
    color: {},
    y: {},
    xPositioning: {},
    yPositioning: {},
    labelFontSize: {},
    label: {},
    backgroundColor: {},
    cursor: {},
    labelTextBrightnessRatio: {},
    clustering: { type: Boolean },
    clusterLabel: {},
    clusterFontSize: {},
    clusterBackgroundColor: {},
    clusterCursor: {},
    clusterLabelColor: {},
    x: {},
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(i, { expose: p }) {
    const t2 = inject(o), c2 = i, a = computed(() => t2.data.value ?? c2.data), n = m(c2), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new XYLabels(n.value), (e2 = o2.value) == null || e2.setData(a.value), t2.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), t2.destroy();
    }), watch(n, (e2, r) => {
      var s2;
      f(e2, r) || (s2 = o2.value) == null || s2.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(a.value);
    }), p({
      component: o2
    }), (e2, r) => (openBlock(), createElementBlock("div", k3));
  }
});

// node_modules/@unovis/vue/components/chord-diagram/index.js
var D5 = { "data-vis-component": "" };
var B3 = ChordDiagram.selectors;
var I = defineComponent({
  __name: "index",
  props: {
    angleRange: {},
    cornerRadius: {},
    highlightedNodeId: {},
    highlightedLinkIds: {},
    linkColor: {},
    linkValue: {},
    nodeLevels: {},
    nodeWidth: {},
    nodeColor: {},
    nodeLabel: {},
    nodeLabelColor: {},
    nodeLabelAlignment: {},
    padAngle: {},
    radiusScaleExponent: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(i, { expose: u }) {
    const t2 = inject(o), r = i, a = computed(() => t2.data.value ?? r.data), n = m(r), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new ChordDiagram(n.value), (e2 = o2.value) == null || e2.setData(a.value), t2.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), t2.destroy();
    }), watch(n, (e2, s2) => {
      var d;
      f(e2, s2) || (d = o2.value) == null || d.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(a.value);
    }), u({
      component: o2
    }), (e2, s2) => (openBlock(), createElementBlock("div", D5));
  }
});

// node_modules/@unovis/vue/components/donut/index.js
var x = { "data-vis-component": "" };
var F = Donut.selectors;
var E3 = defineComponent({
  __name: "index",
  props: {
    id: { type: Function },
    value: {},
    angleRange: {},
    padAngle: {},
    sortFunction: { type: Function },
    cornerRadius: {},
    color: {},
    radius: {},
    arcWidth: {},
    centralLabel: {},
    centralSubLabel: {},
    centralSubLabelWrap: { type: Boolean },
    showEmptySegments: { type: Boolean },
    emptySegmentAngle: {},
    showBackground: { type: Boolean },
    backgroundAngleRange: {},
    centralLabelOffsetX: {},
    centralLabelOffsetY: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: d }) {
    const o2 = inject(o), r = p, a = computed(() => o2.data.value ?? r.data), n = m(r), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Donut(n.value), (e2 = t2.value) == null || e2.setData(a.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(n, (e2, c2) => {
      var s2;
      f(e2, c2) || (s2 = t2.value) == null || s2.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(a.value);
    }), d({
      component: t2
    }), (e2, c2) => (openBlock(), createElementBlock("div", x));
  }
});

// node_modules/@unovis/vue/components/graph/index.js
var E4 = { "data-vis-component": "" };
var G = Graph.selectors;
var D6 = defineComponent({
  __name: "index",
  props: {
    zoomScaleExtent: {},
    disableZoom: { type: Boolean },
    zoomEventFilter: { type: Function },
    disableDrag: { type: Boolean },
    disableBrush: { type: Boolean },
    zoomThrottledUpdateNodeThreshold: {},
    layoutType: {},
    layoutAutofit: { type: Boolean },
    layoutAutofitTolerance: {},
    layoutNonConnectedAside: { type: Boolean },
    layoutNodeGroup: {},
    layoutGroupOrder: {},
    layoutParallelNodesPerColumn: {},
    layoutParallelNodeSubGroup: {},
    layoutParallelSubGroupsPerRow: {},
    layoutParallelGroupSpacing: {},
    layoutParallelSortConnectionsByGroup: {},
    forceLayoutSettings: {},
    dagreLayoutSettings: {},
    layoutElkSettings: {},
    layoutElkNodeGroups: {},
    layoutElkGetNodeShape: { type: Function },
    linkWidth: {},
    linkStyle: {},
    linkBandWidth: {},
    linkArrow: {},
    linkStroke: {},
    linkDisabled: {},
    linkFlow: {},
    linkFlowAnimDuration: {},
    linkFlowParticleSize: {},
    linkLabel: {},
    linkLabelShiftFromCenter: {},
    linkNeighborSpacing: {},
    linkCurvature: {},
    linkHighlightOnHover: { type: Boolean },
    linkSourcePointOffset: {},
    linkTargetPointOffset: {},
    selectedLinkId: {},
    nodeSize: {},
    nodeStrokeWidth: {},
    nodeShape: {},
    nodeGaugeValue: {},
    nodeGaugeFill: {},
    nodeGaugeAnimDuration: {},
    nodeIcon: {},
    nodeIconSize: {},
    nodeLabel: {},
    nodeLabelTrim: {},
    nodeLabelTrimMode: {},
    nodeLabelTrimLength: {},
    nodeSubLabel: {},
    nodeSubLabelTrim: {},
    nodeSubLabelTrimMode: {},
    nodeSubLabelTrimLength: {},
    nodeSideLabels: {},
    nodeBottomIcon: {},
    nodeDisabled: {},
    nodeFill: {},
    nodeStroke: {},
    nodeSort: { type: Function },
    nodeEnterPosition: {},
    nodeEnterScale: {},
    nodeExitPosition: {},
    nodeExitScale: {},
    nodeEnterCustomRenderFunction: { type: Function },
    nodeUpdateCustomRenderFunction: { type: Function },
    nodePartialUpdateCustomRenderFunction: { type: Function },
    nodeExitCustomRenderFunction: { type: Function },
    nodeOnZoomCustomRenderFunction: { type: Function },
    nodeSelectionHighlightMode: {},
    selectedNodeId: {},
    selectedNodeIds: {},
    panels: {},
    onNodeDragStart: { type: Function },
    onNodeDrag: { type: Function },
    onNodeDragEnd: { type: Function },
    onZoom: { type: Function },
    onZoomStart: { type: Function },
    onZoomEnd: { type: Function },
    onLayoutCalculated: { type: Function },
    onNodeSelectionBrush: { type: Function },
    onNodeSelectionDrag: { type: Function },
    onRenderComplete: { type: Function },
    shouldDataUpdate: { type: Function },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c2, { expose: s2 }) {
    const n = inject(o), l = c2, t2 = computed(() => n.data.value ?? l.data), a = m(l), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new Graph(a.value), (e2 = o2.value) == null || e2.setData(t2.value), n.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), n.destroy();
    }), watch(a, (e2, i) => {
      var d;
      f(e2, i) || (d = o2.value) == null || d.setConfig(a.value);
    }), watch(t2, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(t2.value);
    }), s2({
      component: o2
    }), (e2, i) => (openBlock(), createElementBlock("div", E4));
  }
});

// node_modules/@unovis/vue/components/nested-donut/index.js
var L = { "data-vis-component": "" };
var E5 = NestedDonut.selectors;
var P2 = defineComponent({
  __name: "index",
  props: {
    angleRange: {},
    direction: {},
    value: {},
    centralLabel: {},
    centralSubLabel: {},
    centralSubLabelWrap: { type: Boolean },
    showBackground: { type: Boolean },
    sort: { type: Function },
    layers: {},
    layerSettings: {},
    layerPadding: {},
    cornerRadius: {},
    emptySegmentAngle: {},
    hideOverflowingSegmentLabels: { type: Boolean },
    segmentColor: {},
    segmentLabel: {},
    segmentLabelColor: {},
    showEmptySegments: { type: Boolean },
    showSegmentLabels: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: d }) {
    const o2 = inject(o), s2 = p, a = computed(() => o2.data.value ?? s2.data), n = m(s2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new NestedDonut(n.value), (e2 = t2.value) == null || e2.setData(a.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(n, (e2, r) => {
      var l;
      f(e2, r) || (l = t2.value) == null || l.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(a.value);
    }), d({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", L));
  }
});

// node_modules/@unovis/vue/components/sankey/index.js
var F2 = { "data-vis-component": "" };
var H = Sankey.selectors;
var M2 = defineComponent({
  __name: "index",
  props: {
    id: { type: Function },
    heightNormalizationCoeff: {},
    exitTransitionType: {},
    enterTransitionType: {},
    highlightSubtreeOnHover: { type: Boolean },
    highlightDuration: {},
    highlightDelay: {},
    iterations: {},
    nodeSort: { type: [Function, null] },
    linkSort: { type: [Function, null] },
    nodeWidth: {},
    nodeAlign: {},
    nodeHorizontalSpacing: {},
    nodeMinHeight: {},
    nodeMaxHeight: {},
    nodePadding: {},
    showSingleNode: { type: Boolean },
    nodeCursor: {},
    nodeIcon: {},
    nodeColor: {},
    nodeFixedValue: {},
    nodeIconColor: {},
    linkColor: {},
    linkValue: {},
    linkCursor: {},
    label: {},
    subLabel: {},
    labelPosition: {},
    labelVerticalAlign: {},
    labelBackground: { type: Boolean },
    labelFit: {},
    labelMaxWidth: {},
    labelExpandTrimmedOnHover: { type: Boolean },
    labelTrimMode: {},
    labelFontSize: {},
    labelTextSeparator: {},
    labelForceWordBreak: { type: Boolean },
    labelColor: {},
    labelCursor: {},
    labelVisibility: { type: Function },
    subLabelFontSize: {},
    subLabelColor: {},
    subLabelPlacement: {},
    subLabelToLabelInlineWidthRatio: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u, { expose: c2 }) {
    const n = inject(o), l = u, t2 = computed(() => n.data.value ?? l.data), a = m(l), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new Sankey(a.value), (e2 = o2.value) == null || e2.setData(t2.value), n.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), n.destroy();
    }), watch(a, (e2, i) => {
      var r;
      f(e2, i) || (r = o2.value) == null || r.setConfig(a.value);
    }), watch(t2, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(t2.value);
    }), c2({
      component: o2
    }), (e2, i) => (openBlock(), createElementBlock("div", F2));
  }
});

// node_modules/@unovis/vue/components/topojson-map/index.js
var T = { "data-vis-component": "" };
var j5 = TopoJSONMap.selectors;
var D7 = defineComponent({
  __name: "index",
  props: {
    projection: { type: [Function, Object] },
    topojson: {},
    mapFeatureName: {},
    mapFitToPoints: { type: Boolean },
    zoomFactor: {},
    disableZoom: { type: Boolean },
    zoomExtent: {},
    zoomDuration: {},
    linkWidth: {},
    linkColor: {},
    linkCursor: {},
    linkId: {},
    linkSource: { type: Function },
    linkTarget: { type: Function },
    areaId: {},
    areaColor: {},
    areaCursor: {},
    pointColor: {},
    pointRadius: {},
    pointStrokeWidth: {},
    pointCursor: {},
    longitude: {},
    latitude: {},
    pointLabel: {},
    pointLabelPosition: {},
    pointLabelTextBrightnessRatio: {},
    pointId: { type: Function },
    heatmapMode: { type: Boolean },
    heatmapModeBlurStdDeviation: {},
    heatmapModeZoomLevelThreshold: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c2, { expose: u }) {
    const t2 = inject(o), i = c2, a = computed(() => t2.data.value ?? i.data), n = m(i), e2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var o2;
        e2.value = new TopoJSONMap(n.value), (o2 = e2.value) == null || o2.setData(a.value), t2.update(e2.value);
      });
    }), onUnmounted(() => {
      var o2;
      (o2 = e2.value) == null || o2.destroy(), t2.destroy();
    }), watch(n, (o2, r) => {
      var p;
      f(o2, r) || (p = e2.value) == null || p.setConfig(n.value);
    }), watch(a, () => {
      var o2;
      (o2 = e2.value) == null || o2.setData(a.value);
    }), u({
      component: e2
    }), (o2, r) => (openBlock(), createElementBlock("div", T));
  }
});

// node_modules/@unovis/vue/components/tooltip/index.js
var g2 = { "data-vis-tooltip": "" };
var T2 = Tooltip.selectors;
var z2 = defineComponent({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    data: {}
  },
  setup(c2, { expose: l }) {
    const r = inject(s), t2 = m(c2), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        o2.value = new Tooltip(t2.value), r.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), r.destroy();
    }), watch(t2, (e2, n) => {
      var s2;
      f(e2, n) || (s2 = o2.value) == null || s2.setConfig(t2.value);
    }), l({
      component: o2
    }), (e2, n) => (openBlock(), createElementBlock("div", g2));
  }
});

// node_modules/@unovis/vue/components/annotations/index.js
var y = { "data-vis-annotations": "" };
var P3 = Annotations.selectors;
var b4 = defineComponent({
  __name: "index",
  props: {
    items: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c2, { expose: i }) {
    const n = inject(t), t2 = m(c2), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        o2.value = new Annotations(t2.value), n.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), n.destroy();
    }), watch(t2, (e2, s2) => {
      var r;
      f(e2, s2) || (r = o2.value) == null || r.setConfig(t2.value);
    }), i({
      component: o2
    }), (e2, s2) => (openBlock(), createElementBlock("div", y));
  }
});

// node_modules/@unovis/vue/html-components/leaflet-map/index.js
var F3 = LeafletMap.selectors;
var w5 = defineComponent({
  __name: "index",
  props: {
    width: {},
    height: {},
    flyToDuration: {},
    fitViewPadding: {},
    zoomDuration: {},
    initialBounds: {},
    fitBoundsOnUpdate: {},
    fitViewOnInit: { type: Boolean },
    fitViewOnUpdate: { type: Boolean },
    style: {},
    styleDarkTheme: {},
    accessToken: {},
    attribution: {},
    renderer: {},
    onMapInitialized: { type: Function },
    onMapMoveZoom: { type: Function },
    onMapMoveStart: { type: Function },
    onMapMoveEnd: { type: Function },
    onMapZoomStart: { type: Function },
    onMapZoomEnd: { type: Function },
    onMapClick: { type: Function },
    pointLongitude: {},
    pointLatitude: {},
    pointId: {},
    pointShape: {},
    pointColor: {},
    pointRadius: {},
    pointLabel: {},
    pointLabelColor: {},
    pointBottomLabel: {},
    pointCursor: {},
    pointRingWidth: {},
    selectedPointId: {},
    clusterColor: {},
    clusterRadius: {},
    clusterLabel: {},
    clusterLabelColor: {},
    clusterBottomLabel: {},
    clusterRingWidth: {},
    clusterBackground: { type: Boolean },
    clusterExpandOnClick: { type: Boolean },
    clusteringDistance: {},
    colorMap: {},
    topoJSONLayer: {},
    tooltip: {},
    ariaLabel: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u, { expose: c2 }) {
    const a = u, s2 = computed(() => a.data), o2 = m(a), e2 = ref(), n = ref();
    return onMounted(() => {
      nextTick(() => {
        n.value && (e2.value = new LeafletMap(n.value, o2.value, s2.value));
      });
    }), onUnmounted(() => {
      var t2;
      (t2 = e2.value) == null || t2.destroy();
    }), watch(o2, (t2, i) => {
      var l;
      f(t2, i) || (l = e2.value) == null || l.setConfig(o2.value);
    }), c2({
      component: e2
    }), (t2, i) => (openBlock(), createElementBlock("div", {
      "data-vis-leaflet-map": "",
      ref_key: "elRef",
      ref: n
    }, null, 512));
  }
});

// node_modules/@unovis/vue/html-components/leaflet-flow-map/index.js
var k4 = LeafletFlowMap.selectors;
var b5 = defineComponent({
  __name: "index",
  props: {
    sourceLongitude: {},
    sourceLatitude: {},
    targetLongitude: {},
    targetLatitude: {},
    sourcePointRadius: {},
    sourcePointColor: {},
    flowParticleColor: {},
    flowParticleRadius: {},
    flowParticleSpeed: {},
    flowParticleDensity: {},
    onSourcePointClick: { type: Function },
    onSourcePointMouseEnter: { type: Function },
    onSourcePointMouseLeave: { type: Function },
    width: {},
    height: {},
    flyToDuration: {},
    fitViewPadding: {},
    zoomDuration: {},
    initialBounds: {},
    fitBoundsOnUpdate: {},
    fitViewOnInit: { type: Boolean },
    fitViewOnUpdate: { type: Boolean },
    style: {},
    styleDarkTheme: {},
    accessToken: {},
    attribution: {},
    renderer: {},
    onMapInitialized: { type: Function },
    onMapMoveZoom: { type: Function },
    onMapMoveStart: { type: Function },
    onMapMoveEnd: { type: Function },
    onMapZoomStart: { type: Function },
    onMapZoomEnd: { type: Function },
    onMapClick: { type: Function },
    pointLongitude: {},
    pointLatitude: {},
    pointId: {},
    pointShape: {},
    pointColor: {},
    pointRadius: {},
    pointLabel: {},
    pointLabelColor: {},
    pointBottomLabel: {},
    pointCursor: {},
    pointRingWidth: {},
    selectedPointId: {},
    clusterColor: {},
    clusterRadius: {},
    clusterLabel: {},
    clusterLabelColor: {},
    clusterBottomLabel: {},
    clusterRingWidth: {},
    clusterBackground: { type: Boolean },
    clusterExpandOnClick: { type: Boolean },
    clusteringDistance: {},
    colorMap: {},
    topoJSONLayer: {},
    tooltip: {},
    ariaLabel: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c2, { expose: p }) {
    const i = c2, s2 = computed(() => i.data), t2 = m(i), e2 = ref(), n = ref();
    return onMounted(() => {
      nextTick(() => {
        n.value && (e2.value = new LeafletFlowMap(n.value, t2.value, s2.value));
      });
    }), onUnmounted(() => {
      var o2;
      (o2 = e2.value) == null || o2.destroy();
    }), watch(t2, (o2, a) => {
      var l;
      f(o2, a) || (l = e2.value) == null || l.setConfig(t2.value);
    }), p({
      component: e2
    }), (o2, a) => (openBlock(), createElementBlock("div", {
      "data-vis-leaflet-flow-map": "",
      ref_key: "elRef",
      ref: n
    }, null, 512));
  }
});

// node_modules/@unovis/vue/html-components/bullet-legend/index.js
var P4 = BulletLegend.selectors;
var S3 = defineComponent({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletShape: {},
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(s2, { expose: i }) {
    const l = s2;
    computed(() => l.data);
    const t2 = m(l), o2 = ref(), n = ref();
    return onMounted(() => {
      nextTick(() => {
        n.value && (o2.value = new BulletLegend(n.value, { ...t2.value, renderIntoProvidedDomNode: true }));
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy();
    }), watch(t2, (e2, a) => {
      var r;
      f(e2, a) || (r = o2.value) == null || r.update(t2.value);
    }), i({
      component: o2
    }), (e2, a) => (openBlock(), createElementBlock("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: n
    }, null, 512));
  }
});

// node_modules/@unovis/vue/index.js
(function() {
  "use strict";
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-map],[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend]{display:block}")), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
export {
  b4 as VisAnnotations,
  P3 as VisAnnotationsSelectors,
  P as VisArea,
  D as VisAreaSelectors,
  O as VisAxis,
  M as VisAxisSelectors,
  E as VisBrush,
  D2 as VisBrushSelectors,
  S3 as VisBulletLegend,
  P4 as VisBulletLegendSelectors,
  I as VisChordDiagram,
  B3 as VisChordDiagramSelectors,
  A as VisCrosshair,
  q as VisCrosshairSelectors,
  E3 as VisDonut,
  F as VisDonutSelectors,
  E2 as VisFreeBrush,
  D3 as VisFreeBrushSelectors,
  D6 as VisGraph,
  G as VisGraphSelectors,
  D4 as VisGroupedBar,
  w as VisGroupedBarSelectors,
  b5 as VisLeafletFlowMap,
  k4 as VisLeafletFlowMapSelectors,
  w5 as VisLeafletMap,
  F3 as VisLeafletMapSelectors,
  S2 as VisLine,
  O2 as VisLineSelectors,
  P2 as VisNestedDonut,
  E5 as VisNestedDonutSelectors,
  M2 as VisSankey,
  H as VisSankeySelectors,
  z as VisScatter,
  w2 as VisScatterSelectors,
  b as VisSingleContainer,
  w3 as VisStackedBar,
  j2 as VisStackedBarSelectors,
  q2 as VisTimeline,
  j3 as VisTimelineSelectors,
  z2 as VisTooltip,
  T2 as VisTooltipSelectors,
  D7 as VisTopoJSONMap,
  j5 as VisTopoJSONMapSelectors,
  $ as VisXYContainer,
  w4 as VisXYLabels,
  j4 as VisXYLabelsSelectors
};
//# sourceMappingURL=@unovis_vue.js.map
